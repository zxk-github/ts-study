# ts-study

**D1**
## 基础数据类型
1. 元组可以调用数组的push方法，增加元祖的元素，但是当通过下标访问增加的元素的时候，ts是不允许的。
2. 直接通过类型定义一个object对象，这时候修改对象的key值是不被允许的，因为仅仅定义了类型，并没有声明属性  
例如let obj:object = {x: 1}; obj.x=2; //error
3. 没有返回值的函数就是void类型
4. never表示永远不会有返回值错误抛出函数，死循环函数

## 枚举类型
枚举：一组具有名字的常量集合
#### 枚举类型
1. 数字枚举：可以进行反向映射，可以访问值和key值
2. 字符串枚举：不能进行反向映射，只能访问值
3. 枚举成员的值定义之后不能修改
#### 枚举成员
1. const number 会在变异阶段就计算出结果，以常量的形式出现在运行环境
2. 需要被计算的枚举，不会在编译阶段被计算，而是会保留在运行时
#### 常量枚举  
1. const声明的枚举  
2. 在编译阶段会被移除
3. 当不需要对象，而是需要对象的值的时候，就可以使用常量枚举，减少在编译环境的代码
#### 枚举类型 
1. 在一些情况下，枚举和枚举成员都可以当作一种单独的类型存在，要求所有成员都是字符串或者数字
2. 两种不同了类型的枚举不可以进行比较


**D2**
## 接口
#### 对象类型接口
1. 传入对象变量满足接口的必要条件，那么就是被允许的，即使传入多余的字段也可以通过类型检查，但是如果传入的是对象字面量，那么就不允许有多余的属性存在。  
解决办法：1. 将对象保存在变量中 2. 采用断言 3. 定义一个字符串索引签名 
2. 当不确定一个对象中有多少个属性的时候，就可以使用可索引属性(字符串索引或者数字索引)
#### 函数类型
三种方式  
1. 变量定义函数类型
2. 接口定义函数类型
3. type关键字定义函数类型
#### 混合类型接口

## 函数
1. ts中函数形参和实参必须一一对应
2. 函数可选参数必须要在必选参数之后
3. 必选参数之后的默认值可以不传
4. 函数重载，如果两个函数的名称相同，但是参数个数或者类型不同，就可以实现一个函数重载，函数重载的好处就是不需要为了功能相似的函数，选择不同的函数名称，这样就可以增强函数的可读性

## 类
ts的类覆盖了es6中的类
constructor使用private修饰之后，当前的类既不能被实例化，也不能被继承
constructor使用protected修饰之后，当前类只能被继承，不能被实例化
readonly 修饰的属性，在实力化之后不能赋值

## 抽象类
只能被继承不能被实力化
抽象类中可以定义具体的方法实现，也可以定义一个抽象函数，抽象函数必须在子类中实现

#### 接口和类混合使用
接口可以约束类成员有哪些属性以及对应的类型，类实现接口的时候，必须实现接口中定义的所有属性并且是共有成员，所以接口不能约束构造函数construtor

#### 接口的继承
1. 通过接口的继承可以抽离出公共的接口，并且可以把多个接口合并成一个接口

#### 接口继承类
接口继承类就相当于把类的成员都抽离出来，就相当于只有结构，没有具体的实现，在抽离结构的时候，类的私有成员也都会抽离出来

## 泛型
泛型：不预先确定的数据类型，具体的类型在使用的时候才能确定。
1. any类型会忽略类型间的关系，比如会忽略函数参数和返回值之间类型的关系
2. 使用type关键字可以定义一个泛型类型
3. 约束类的成员，但是泛型不能约束类的静态成员  
函数和类可以轻松地支持多种类型，增强程序的扩展性  
不必写多条函数重载或者繁琐的联合类型声明，增强代码的可读性  
灵活控制类型之前的约束

## 类型检查机制
Typescript编译器在做类型检查时，所秉承的一些原则，以及表现出的一些行为
作用：辅助开发，提高开发效率
#### 类型推断
1. 有时候不需要设置类型，但是会根据一下规则推断出类型
###### 基础类型推断
表达式右侧的值，推断出左侧变量的类型
let a = 1;
let b = [1]
let c = (x = 1) => x + 1;
最佳类型推断： 当需要从多个类型中推断出一个类型，ts就会推断出兼容所有类型的通用类型
###### 上下文类型推断
通常发生在事件处理中，根据左侧的时间，推断出时间类型
#### 类型断言
允许使用自己的类型覆盖ts的推断
#### 类型保护

## 类型兼容性
当一个类型Y可以被赋值给另一个类型X时，我们就可以说类型X兼容类型Y
ts允许把一些类型不同的变量相互赋值，比如null可以赋值给字符串类型的变量,源类型必须要有目标类型的必要属性，接口之间相互兼容的时候，成员少的会兼容成员多的

#### 函数兼容性
1. 参数个数  
固定参数可以兼容可选参数和剩余参数  
可选参数不可以兼容固定参数和剩余参数（strictFunctionTypes：false）  
剩余参数可以兼容固定参数和可选参数  

2. 参数类型

3. 返回值类型
目标函数的返回值类型，必须与原函数的返回值类型相同或者为其子类型，成员少的可以兼容成员多的
函数重载的时候，目标函数参数不能少于实现函数的参数

#### 枚举类型的兼容性
同一枚举类型之间是相互兼容的，不同枚举类型之间是不兼容的

#### 类的兼容性
类的兼容性和接口比较类似，他们只比较结构，静态成员和构造函数不相互比较，如果两个类有相同的实例成员，那么这两个实例就相互兼容
如果类中有私有成员，那么这两个类就不互相兼容了，但是如果实例的构造函数之间是相互继承的关系，这时候有私有属性，也是可以相互兼容的

#### 泛型的兼容性
只有类型T被接口成员使用的时候，才会影响泛型的兼容性
如果两个泛型函数没有范型类型，那么也是相互兼容的

结构之间兼容，成员少的兼容成员多的
函数之间兼容，参数多的兼容参数少的


## 类型保护
ts能够在特定的区块中保证变量属于某种确定的类型
可以在此区块中放心地引用此类型的属性，或者调用此此类型的方法
instanceof 
in 
typeof 
写一个类型保护函数
function isJava(lang: Java | Js): lang is Java {
  return (lang as Java).helloJava !== undefined
}

## ts高级类型
交叉类型
将多个类型合并成一个类型，新的类型将具有所有类型的特性，其实就是取类型的并集，所以交叉类型特别适合对象混入的场景

联合类型
声明的变量类型不确定，可以是多个类型中的一个
如果一个类型是联合类型，在对象类型没有确定的情况下，那就只能访问对象的共有成员

可区分的联合类型
结合了联合类型和字面量类型的一种类型保护方法，核心思想是一个类型是多个类型的联合类型，并且每个类型之间有一个公共的属性，就可以凭借这个公共类型属性创建不同的类型保护区快


索引类型
keyof关键子可以提取出一个对象的key值组成的联合类型
let key: keyof Obj1 = 'a'

索引访问操作符 T[K]
let value = Obj['a']

泛型约束
泛型变量可以通过继承某一个类型获取对应类型的属性
T extends U

映射类型
通过映射类型可以从一个旧的类型生成一个新的类型
内置运算符
Readonly<T> 将一个类型的所有属性都变为只读的
Partial<T> 将一个类型的所有属性都为可选的
Pick<T, 'a' | 'b'> 抽取类型的对应类型作为新类型的子集
Record<'x' | 'y', T> 生成一个新的类型，新类型的每一个key都是T

条件类型
条件类型是一个由条件表达式所决定的类型
T extends U? X : Y
如果类型T可以被赋值给类型U，那么结果类型就是X，否则就是Y


ts支持es6模块和commonjs模块

ts-node可以在node端执行ts代码


## ts config配置

#### 文件相关的选项
files: [] 编译器可以编译的单个文件列表
include: [] 编译需要编译的文件或者目录
  src/* 只会编译src下的1级目录下的文件
  src/*/* 只会编译src二级下的文件

exclude: [] 某一个目录或者不需要编译

extends: './tsconfig.base.json' 配置文件可以继承的，可以抽离基础配置，方便复用

compileOnSave: true 在保存文件的时候，编译器自动编译

#### 编译相关选项


#### 工程引用 ts3.0
每一个文件夹都可以根据自己文件夹下的tsconfig.json进行编译
灵活配置输出目录，还可以使不同工程之间产生依赖关系，有利于把大的项目拆分成小的项目，同时还可以利用增量编译提升编译速度

tsc -b src/server --verbose



fork-ts-ckecker-webpack-plugin 
上面这个插件会把ts的类型检查放在一个独立的线程中进行

awesome-typescript-loader 
与ts-loader区别   
1. 更合适与babel集成，使用Babel的转义和缓存  
2. 不需要安装额外的插件，就可以把类型检查放在独立进程中进行 

如果没有使用babel，首先Typescript自身的编译器(可配合ts-loader使用) 
如果项目中已经使用了babel，安装@babel/preset-typescript（可配合tsc做类型检查） 
两种编译工具不要混合使用  

typescript-eslint
tslint是在ts语法树的基础上工作的

eslint和ts的抽象语法树不兼容

