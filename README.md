# ts-study

**D1**
## 基础数据类型
1. 元组可以调用数组的push方法，增加元祖的元素，但是当通过下标访问增加的元素的时候，ts是不允许的。
2. 直接通过类型定义一个object对象，这时候修改对象的key值是不被允许的，因为仅仅定义了类型，并没有声明属性  
例如let obj:object = {x: 1}; obj.x=2; //error
3. 没有返回值的函数就是void类型
4. never表示永远不会有返回值错误抛出函数，死循环函数

## 枚举类型
枚举：一组具有名字的常量集合
#### 枚举类型
1. 数字枚举：可以进行反向映射，可以访问值和key值
2. 字符串枚举：不能进行反向映射，只能访问值
3. 枚举成员的值定义之后不能修改
#### 枚举成员
1. const number 会在变异阶段就计算出结果，以常量的形式出现在运行环境
2. 需要被计算的枚举，不会在编译阶段被计算，而是会保留在运行时
#### 常量枚举  
1. const声明的枚举  
2. 在编译阶段会被移除
3. 当不需要对象，而是需要对象的值的时候，就可以使用常量枚举，减少在编译环境的代码
#### 枚举类型 
1. 在一些情况下，枚举和枚举成员都可以当作一种单独的类型存在，要求所有成员都是字符串或者数字
2. 两种不同了类型的枚举不可以进行比较


**D2**
## 接口
#### 对象类型接口
1. 传入对象变量满足接口的必要条件，那么就是被允许的，即使传入多余的字段也可以通过类型检查，但是如果传入的是对象字面量，那么就不允许有多余的属性存在。  
解决办法：1. 将对象保存在变量中 2. 采用断言 3. 定义一个字符串索引签名 
2. 当不确定一个对象中有多少个属性的时候，就可以使用可索引属性(字符串索引或者数字索引)
#### 函数类型
三种方式  
1. 变量定义函数类型
2. 接口定义函数类型
3. type关键字定义函数类型
#### 混合类型接口

## 函数
1. ts中函数形参和实参必须一一对应
2. 函数可选参数必须要在必选参数之后
3. 必选参数之后的默认值可以不传
4. 函数重载，如果两个函数的名称相同，但是参数个数或者类型不同，就可以实现一个函数重载，函数重载的好处就是不需要为了功能相似的函数，选择不同的函数名称，这样就可以增强函数的可读性

## 类
ts的类覆盖了es6中的类
constructor使用private修饰之后，当前的类既不能被实例化，也不能被继承
constructor使用protected修饰之后，当前类只能被继承，不能被实例化
readonly 修饰的属性，在实力化之后不能赋值

## 抽象类
只能被继承不能被实力化
抽象类中可以定义具体的方法实现，也可以定义一个抽象函数，抽象函数必须在子类中实现

#### 接口和类混合使用
接口可以约束类成员有哪些属性以及对应的类型，类实现接口的时候，必须实现接口中定义的所有属性并且是共有成员，所以接口不能约束构造函数construtor

#### 接口的继承
1. 通过接口的继承可以抽离出公共的接口，并且可以把多个接口合并成一个接口

#### 接口继承类
接口继承类就相当于把类的成员都抽离出来，就相当于只有结构，没有具体的实现，在抽离结构的时候，类的私有成员也都会抽离出来